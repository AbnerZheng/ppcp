* Exercise2.1

** 1. It takes about 7.396s.

** 3. It takes about 4.076s, it still get correct answer.

** 4. No. Because when just using a volatile field, it could just gurantee visibility without atomicity. There will be some errors in addAndGet.

** 5. It takes about 3.851s when using java.util.concurrent.atomic.AtomicInteger. Almost nothing changed, because I use a local variable 'count' to store the sum of factors which partially calculate and there is no need to declared it final.

* Exercise2.2

** 1. Because the cache will be accessed very frequently, intersected with reading and writing. So the visibility is important, and volatile can gurantee this property.

** 2. In order to maintain immutable. Immutable object is naturelly thread-safe.

* Exercise2.3

** 1. Counts should be `final`. The method `increase` should be `synchronized`.

304057ms :
 0:     41540
   1:       186
   2:    150784
   3:    191810
   4:     97676
   5:     17312
   6:       692
   7:         0
   8:         0
   9:         0
  10:         0
  11:         0
  12:         0
  13:         0
  14:         0
  15:         0
  16:         0
  17:         0
  18:         0
  19:         0
  20:         0
  21:         0
  22:         0
  23:         0
  24:         0
         500000
