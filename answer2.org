* Exercise2.1

** 1. It takes about 7.396s.

** 3. It takes about 4.076s, it still get correct answer.

** 4. No. Because when just using a volatile field, it could just gurantee visibility without atomicity. There will be some errors in addAndGet.

** 5. It takes about 3.851s when using java.util.concurrent.atomic.AtomicInteger. Almost nothing changed, because I use a local variable 'count' to store the sum of factors which partially calculate and there is no need to declared it final.

* Exercise2.2

** 1. Because the cache will be accessed very frequently, intersected with reading and writing. So the visibility is important, and volatile can gurantee this property.

** 2. In order to maintain immutable. Immutable object is naturelly thread-safe.

* Exercise2.3
